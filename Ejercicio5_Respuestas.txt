================================================================================
EJERCICIO 5: SINCRONIZACIÓN - PRODUCTOR/CONSUMIDOR - 2 PUNTOS
================================================================================

1. ¿Es la clase Buffer un hilo?
--------------------------------------------------------------------------------

No, la clase Buffer no es un hilo. Es una clase normal que actúa como monitor 
u objeto compartido. No extiende Thread ni implementa Runnable. Su función es 
ser un objeto compartido entre el Productor y el Consumidor, usando synchronized 
para controlar el acceso concurrente a sus métodos.

Los hilos reales son el Thread productor (que ejecuta la clase Productor) y el 
Thread consumidor (que ejecuta la clase Consumidor). Ambos acceden al mismo 
objeto Buffer compartido.


2. ¿Cuál es el objetivo de la variable dato?
--------------------------------------------------------------------------------

La variable dato es el buffer de tamaño 1 que almacena el dato compartido entre 
productor y consumidor. Su objetivo es almacenar un solo dato a la vez (buffer 
de capacidad 1) y controlar el estado del buffer mediante dos estados posibles: 
cuando dato es null el buffer está vacío y el productor puede poner datos, 
cuando dato no es null el buffer está lleno y el consumidor puede tomar datos.

Este mecanismo permite que el productor espere si el buffer está lleno y que 
el consumidor espere si el buffer está vacío.


3. ¿Qué ocurre si elimino el synchronized de tomar() y luego lo ejecuto?
--------------------------------------------------------------------------------

[CAPTURA 1]

Si eliminamos synchronized de tomar(), el programa lanza inmediatamente una 
excepción IllegalMonitorStateException. Esto ocurre porque wait() requiere que 
el hilo tenga el monitor del objeto. Sin synchronized, wait() no puede funcionar 
y el programa crashea.

Además, sin synchronized habría condiciones de carrera donde el consumidor 
podría leer dato mientras el productor lo está modificando, o múltiples 
consumidores podrían leer el mismo dato.

Conclusión: synchronized es obligatorio para usar wait() y notifyAll().


4. Juega con las 4 posibles combinaciones de los valores de sleep y analiza 
   qué ocurre
--------------------------------------------------------------------------------

Valores originales: Productor sleep(1000), Consumidor sleep(2000)

Combinación 1 - Productor rápido (500ms), Consumidor lento (2000ms):
[CAPTURA 2]
El productor produce más rápido de lo que el consumidor consume. El productor 
se bloquea frecuentemente con el mensaje "Intento poner pero datos ya tiene 
datos". El buffer está lleno la mayor parte del tiempo.

Combinación 2 - Productor lento (2000ms), Consumidor rápido (500ms):
[CAPTURA 3]
El consumidor consume más rápido de lo que el productor produce. El consumidor 
se bloquea frecuentemente con el mensaje "Intengo tomar pero está vacio". El 
buffer está vacío la mayor parte del tiempo.

Combinación 3 - Ambos rápidos (500ms, 500ms):
[CAPTURA 4]
Producción y consumo equilibrados con menos bloqueos y flujo más continuo.

Combinación 4 - Ambos lentos (2000ms, 2000ms):
[CAPTURA 5]
Producción y consumo equilibrados pero lentos. Menos bloqueos pero el programa 
tarda más en completarse.


5. Cambia los notifyAll() por notify() analiza lo que está sucediendo
--------------------------------------------------------------------------------

[CAPTURA 6]

En este código específico con 1 productor y 1 consumidor, no hay diferencia 
visible en el comportamiento. notify() despierta un solo hilo en espera mientras 
que notifyAll() despierta todos los hilos en espera. Como solo hay 2 hilos y 
uno siempre está esperando, notify() funciona correctamente.

Sin embargo, si hubiera múltiples productores o consumidores, notify() podría 
despertar al hilo equivocado y causar deadlock (todos esperando, ninguno 
despierta al correcto). En esos casos, notifyAll() es más seguro.

Conclusión: Con 1 productor y 1 consumidor, notify() funciona igual que 
notifyAll(). Con múltiples productores/consumidores, notifyAll() es más seguro.

================================================================================

