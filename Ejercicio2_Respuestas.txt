EJERCICIO 2 - RESPUESTAS DETALLADAS
====================================

Código analizado: DemoSleep/DemoSleepYieldPriority.java

====================================
PREGUNTA 1: ¿Qué pasa si comento el s1.join() y el s2.join()? ¿Por qué crees que pasa?
====================================

RESPUESTA:
Si comentamos s1.join() y s2.join() (líneas 89-90), el programa principal (main) NO espera 
a que los hilos s1 y s2 terminen su ejecución.

¿Qué ocurre?
- El main continúa inmediatamente después de hacer s1.start() y s2.start()
- Pasa directamente a la siguiente demo (DEMO YIELD) sin esperar
- Las salidas de DEMO SLEEP, DEMO YIELD y DEMO PRIORITY se mezclan
- El programa puede incluso terminar antes de que algunos hilos completen su trabajo

¿Por qué pasa esto?
- El método join() hace que el hilo que lo invoca (main) ESPERE hasta que el hilo 
  sobre el que se llama join() termine completamente
- Sin join(), los hilos se ejecutan de forma ASÍNCRONA e INDEPENDIENTE
- El main no tiene forma de saber cuándo terminan los hilos

Ejemplo de salida SIN join():
  ======= DEMO SLEEP =======
  [Lento] empieza
  [Rápido] empieza
  
  ======= DEMO YIELD =======    <-- Esto aparece antes de que terminen los hilos de sleep
  {SinYield} empieza
  [Rápido] paso 1               <-- Salidas mezcladas
  {ConYield} empieza
  [Lento] paso 1

Ejemplo de salida CON join():
  ======= DEMO SLEEP =======
  [Lento] empieza
  [Rápido] empieza
  [Rápido] paso 1
  [Lento] paso 1
  ...
  [Rápido] termina
  [Lento] termina
  
  ======= DEMO YIELD =======    <-- Esto aparece DESPUÉS de que terminen los hilos de sleep
  {SinYield} empieza
  ...

CONCLUSIÓN: join() es esencial para SINCRONIZAR la ejecución y mantener el orden lógico del programa.


====================================
PREGUNTA 2: ¿Saca por pantalla siempre el "[Lento] empieza"?
====================================

RESPUESTA:
SÍ, SIEMPRE sale "[Lento] empieza" por pantalla.

Explicación:
- El hilo "Lento" se crea y se inicia con s1.start() (línea 87)
- Cuando el hilo comienza su ejecución, lo primero que hace es ejecutar la línea 16:
  System.out.println("[" + name + "] empieza");
- Por lo tanto, SIEMPRE se imprime este mensaje

PERO... ¿Siempre sale PRIMERO?
NO, el ORDEN puede variar:

- Aunque s1.start() se llama antes que s2.start(), esto NO garantiza que "Lento" 
  empiece a ejecutarse antes que "Rápido"
- El planificador de hilos del sistema operativo decide qué hilo ejecutar primero
- Factores que afectan el orden:
  * Carga del sistema
  * Número de núcleos de CPU disponibles
  * Algoritmo de planificación del SO
  * Otros procesos en ejecución

Posibles salidas:

Ejecución 1:
  [Lento] empieza
  [Rápido] empieza

Ejecución 2:
  [Rápido] empieza
  [Lento] empieza

Ejecución 3 (en sistemas multi-núcleo):
  [Lento] empieza
  [Rápido] empieza    <-- Casi simultáneo

CONCLUSIÓN: El mensaje SIEMPRE aparece, pero el ORDEN relativo a otros mensajes NO está garantizado.


====================================
PREGUNTA 3: ¿En la parte de DEMO SLEEP sale siempre el mismo orden?
====================================

RESPUESTA:
NO, el orden NO es siempre exactamente el mismo.

Análisis detallado:

1. INICIO (impredecible):
   - Como vimos en la pregunta anterior, el orden de "[Lento] empieza" y "[Rápido] empieza" 
     puede variar entre ejecuciones

2. DURANTE LA EJECUCIÓN (más predecible pero no determinista):
   - "Rápido" duerme 200ms entre pasos (delay = 200)
   - "Lento" duerme 400ms entre pasos (delay = 400)
   - Por lo tanto, "Rápido" suele avanzar más rápido

   Patrón típico:
   [Lento] empieza
   [Rápido] empieza
   [Rápido] paso 1      <-- 200ms después
   [Lento] paso 1       <-- 400ms después
   [Rápido] paso 2      <-- 400ms después (200ms desde su último paso)
   [Rápido] paso 3      <-- 600ms después
   [Lento] paso 2       <-- 800ms después
   ...

3. VARIACIONES posibles:
   - Si el sistema está ocupado, un hilo puede despertar ligeramente más tarde
   - En sistemas multi-núcleo, ambos hilos pueden ejecutarse en paralelo
   - El orden de impresión puede variar si ambos hilos intentan imprimir simultáneamente

Factores que causan variación:
- Carga del sistema operativo
- Precisión del temporizador (Thread.sleep no es exacto al milisegundo)
- Competencia por recursos (consola, CPU)
- Cambios de contexto del planificador

CONCLUSIÓN: Hay un patrón GENERAL predecible (Rápido avanza más), pero el orden EXACTO 
puede variar ligeramente entre ejecuciones.


====================================
PREGUNTA 4: ¿Si comento "p2.setPriority(Thread.NORM_PRIORITY);" del código 
DemoSleepYieldPriority me queda igual?
====================================

RESPUESTA:
SÍ, queda EXACTAMENTE IGUAL.

Explicación técnica:

1. Valor de Thread.NORM_PRIORITY:
   - Thread.NORM_PRIORITY = 5 (valor constante)

2. Prioridad por defecto de un hilo:
   - Cuando creas un nuevo Thread, automáticamente tiene prioridad NORM_PRIORITY (5)
   - Esta es la prioridad heredada del hilo padre (main)

3. Análisis del código:
   
   Línea 106: Thread p2 = new Thread(new PriorityTask("Prioridad_Media"));
   - En este momento, p2 ya tiene prioridad = 5 (por defecto)
   
   Línea 110: p2.setPriority(Thread.NORM_PRIORITY);
   - Esto establece la prioridad a 5
   - Pero p2 YA TENÍA prioridad 5
   - Por lo tanto, esta línea NO CAMBIA NADA

4. Comparación:

   CON la línea:
   p2.setPriority(Thread.NORM_PRIORITY);  // Prioridad = 5
   
   SIN la línea (comentada):
   // p2.setPriority(Thread.NORM_PRIORITY);  // Prioridad = 5 (por defecto)

   Resultado: IDÉNTICO

5. Contraste con p1 y p3:
   
   p1.setPriority(Thread.MIN_PRIORITY);  // Cambia de 5 a 1 ✓ IMPORTANTE
   p2.setPriority(Thread.NORM_PRIORITY); // Mantiene en 5   ✗ REDUNDANTE
   p3.setPriority(Thread.MAX_PRIORITY);  // Cambia de 5 a 10 ✓ IMPORTANTE

Verificación:
Si ejecutas:
  System.out.println("Prioridad de p2 ANTES de setPriority: " + p2.getPriority());
  // p2.setPriority(Thread.NORM_PRIORITY);
  System.out.println("Prioridad de p2 DESPUÉS (sin setPriority): " + p2.getPriority());

Salida:
  Prioridad de p2 ANTES de setPriority: 5
  Prioridad de p2 DESPUÉS (sin setPriority): 5

CONCLUSIÓN: La línea p2.setPriority(Thread.NORM_PRIORITY) es REDUNDANTE y puede comentarse 
sin ningún efecto en el comportamiento del programa.


====================================
PREGUNTA 5: En la salida del DEMO PRIORITY casi no se ve diferencia entre hilos con 
diferentes prioridades, ¿por qué?
====================================

RESPUESTA:
Hay MÚLTIPLES razones por las que NO se ve una diferencia significativa:

1. LAS PRIORIDADES SON SUGERENCIAS, NO GARANTÍAS
   -----------------------------------------------
   - En Java, setPriority() es una SUGERENCIA al planificador del sistema operativo
   - El SO puede ignorar completamente las prioridades de Java
   - No hay garantía de que un hilo de mayor prioridad se ejecute antes o más tiempo

2. SISTEMAS MULTI-NÚCLEO MODERNOS
   --------------------------------
   - La mayoría de computadoras modernas tienen múltiples núcleos (2, 4, 8, 16...)
   - Si hay 3 hilos y 4 núcleos disponibles, los 3 hilos pueden ejecutarse SIMULTÁNEAMENTE
   - No hay competencia por CPU, por lo que la prioridad es irrelevante
   
   Ejemplo:
   CPU Core 1: [Prioridad_Baja]  ──────────────────────────────
   CPU Core 2: [Prioridad_Media] ──────────────────────────────
   CPU Core 3: [Prioridad_Alta]  ──────────────────────────────
   CPU Core 4: [Idle]
   
   Todos terminan casi al mismo tiempo porque no compiten entre sí.

3. LA TAREA ES MUY CORTA Y SIMILAR
   ---------------------------------
   - Los tres hilos hacen exactamente el mismo trabajo: sumar números de 0 a 50,000,000
   - La tarea toma solo ~80-100 milisegundos
   - No hay suficiente tiempo para que las diferencias de prioridad se manifiesten
   - Todos terminan en tiempos muy similares

   Ejemplo de salida típica:
   [Prioridad_Baja] termina en 84 ms
   [Prioridad_Media] termina en 81 ms
   [Prioridad_Alta] termina en 83 ms
   
   Diferencia: Solo 3ms (insignificante)

4. MAPEO DE PRIORIDADES JAVA → SO
   --------------------------------
   - Java tiene prioridades de 1 a 10
   - Windows tiene prioridades diferentes (7 niveles)
   - Linux tiene prioridades diferentes (nice values -20 a 19)
   - El mapeo NO es directo ni preciso
   - Muchas prioridades de Java se mapean al mismo nivel del SO

5. ALGORITMOS DE PLANIFICACIÓN MODERNOS
   -------------------------------------
   - Los SOs modernos usan planificación EQUITATIVA (fair scheduling)
   - Evitan la INANICIÓN (starvation) de hilos de baja prioridad
   - Usan algoritmos como CFS (Completely Fair Scheduler) en Linux
   - Priorizan la JUSTICIA sobre la prioridad estricta

6. NO HAY OPERACIONES BLOQUEANTES
   --------------------------------
   - Los hilos solo hacen cálculos (CPU-bound)
   - No hay I/O, sleep(), wait(), o sincronización
   - No hay puntos donde el planificador pueda intervenir efectivamente

7. PRECISIÓN DE MEDICIÓN
   ----------------------
   - System.currentTimeMillis() tiene precisión de ~10-15ms en algunos sistemas
   - Diferencias menores a 10ms pueden no detectarse
   - El tiempo de inicio puede variar más que el efecto de la prioridad


CÓMO VER DIFERENCIAS MÁS CLARAS:
=================================

Para observar el efecto de las prioridades, necesitarías:

a) MÁS HILOS compitiendo por CPU:
   - Crear 20-50 hilos en lugar de 3
   - Forzar competencia real por recursos

b) TAREAS MÁS LARGAS:
   - Aumentar el bucle a 500,000,000 o más
   - Dar tiempo al planificador para actuar

c) FORZAR UN SOLO NÚCLEO:
   - Usar afinidad de CPU (CPU affinity)
   - Limitar la JVM a un solo núcleo

d) SISTEMA CON ALTA CARGA:
   - Ejecutar otros procesos intensivos simultáneamente
   - Crear competencia real por CPU

e) OPERACIONES BLOQUEANTES:
   - Añadir sleep(), I/O, o sincronización
   - Dar oportunidades al planificador para cambiar de contexto

Ejemplo de código mejorado para ver diferencias:

```java
// Crear MUCHOS hilos de baja prioridad
for (int i = 0; i < 20; i++) {
    Thread t = new Thread(new PriorityTask("Baja_" + i));
    t.setPriority(Thread.MIN_PRIORITY);
    t.start();
}

// Crear UN hilo de alta prioridad
Thread alta = new Thread(new PriorityTask("ALTA"));
alta.setPriority(Thread.MAX_PRIORITY);
alta.start();

// Ahora sí verás que "ALTA" probablemente termine antes
```


CONCLUSIÓN FINAL:
=================

Las prioridades de hilos en Java son:
- Una característica DÉBIL y poco confiable
- Dependientes del sistema operativo
- Inefectivas en sistemas multi-núcleo modernos con poca carga
- Útiles solo en escenarios muy específicos con alta competencia por CPU

En la práctica profesional:
- NO se recomienda depender de prioridades para lógica crítica
- Es mejor usar mecanismos explícitos de sincronización y coordinación
- Las prioridades son más una "optimización sugerida" que una garantía


====================================
RESUMEN DE CONCEPTOS CLAVE
====================================

1. join() → Sincronización: espera a que un hilo termine
2. start() → Inicio asíncrono: el orden de ejecución no está garantizado
3. sleep() → Pausa temporal: libera CPU pero no es exacto
4. setPriority() → Sugerencia débil: el SO puede ignorarla
5. Multi-threading → No determinista: el orden puede variar entre ejecuciones
6. Multi-core → Paralelismo real: reduce competencia y efecto de prioridades


====================================
INSTRUCCIONES PARA CAPTURAS DE PANTALLA
====================================

Para completar el ejercicio, necesitas tomar capturas de:

1. Ejecución NORMAL del programa (con join())
2. Ejecución SIN join() (comentar líneas 89-90) mostrando salidas mezcladas
3. Varias ejecuciones mostrando diferentes órdenes en DEMO SLEEP
4. Ejecución CON y SIN p2.setPriority() mostrando que es igual
5. Salida de DEMO PRIORITY mostrando tiempos similares

Comandos para ejecutar:
  cd "c:\Users\rogergongas\Desktop\codigo seguro\Pruebas-Seguridad"
  javac DemoSleep\DemoSleepYieldPriority.java
  java DemoSleep.DemoSleepYieldPriority
